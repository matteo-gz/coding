<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>微服务 on Coding cheat sheet</title>
    <link>https://matteo-gz.github.io/coding/docs/ms/</link>
    <description>Recent content in 微服务 on Coding cheat sheet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://matteo-gz.github.io/coding/docs/ms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go框架</title>
      <link>https://matteo-gz.github.io/coding/docs/ms/framework/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/ms/framework/</guid>
      <description>简介 # https://www.techempower.com/benchmarks/
web框架 # gin doc github echo doc github hertz doc github star-history
数据库框架 # ent doc github gorm doc github star-history
微服务框架 # 来源 go-kratos doc github bilibili kitex doc github 字节跳动 go-zero doc github 晓黑板 TarsGo github 腾讯 star-history</description>
    </item>
    
    <item>
      <title>k8s</title>
      <link>https://matteo-gz.github.io/coding/docs/ms/kubernetes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/ms/kubernetes/</guid>
      <description>极客时间.深入剖析 Kubernetes
容器基础 # 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个&amp;quot;边界&amp;quot;.
Cgroups 技术// 制造约束 Namespace 技术//修改进程视图 Namespace # 用来对各种不同的进程上下文进行“障眼法”操作
PID Mount UTS IPC Network User Cgroup // Linux 内核从 4.6 开始 PID namespace # 对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 多次执行上面的 clone(),就会创建多个 PID Namespace,每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况
障眼法 # Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时， Docker 为它们加上了各种各样的 Namespace 参数。
这时，这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程， 只能看到各自 Mount Namespace 里挂载的目录和文件， 只能访问到各自 Network Namespace 里的网络设备， 就仿佛运行在一个个“容器”里面，与世隔绝。</description>
    </item>
    
    <item>
      <title>k8s网络</title>
      <link>https://matteo-gz.github.io/coding/docs/ms/k8s_network/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/ms/k8s_network/</guid>
      <description>网络栈 # 网卡（Network Interface） 回环设备（Loopback Device） 路由表（Routing Table） iptables 规则 被隔离在它自己的 Network Namespace 当中的
在大多数情况下，我们都希望容器进程能使用自己 Network Namespace 里的网络栈，即：拥有属于自己的 IP 地址和端口</description>
    </item>
    
    <item>
      <title>kratos框架</title>
      <link>https://matteo-gz.github.io/coding/docs/ms/kratos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/ms/kratos/</guid>
      <description> 服务发现 # 熔断 # 用于提供客户端熔断功能
限流 # 用于服务端流量控制
其他 # 重试 降级 排队 </description>
    </item>
    
    <item>
      <title>服务发现</title>
      <link>https://matteo-gz.github.io/coding/docs/ms/discovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/ms/discovery/</guid>
      <description> 服务发现 # star-history
consul etcd 配置中心 # 方案
apollo nacos </description>
    </item>
    
    <item>
      <title>领域驱动设计</title>
      <link>https://matteo-gz.github.io/coding/docs/ms/ddd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/ms/ddd/</guid>
      <description>极客时间.DDD 实战课
领域边界 # 在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出领域实体等领域对象 根据领域实体之间的业务关联性，将业务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。在这个图里，聚合之间的边界是第一层边界，它们在同一个微服务实例中运行，这个边界是逻辑边界，所以用虚线表示 根据业务及语义边界等因素，将一个或者多个聚合划定在一个限界上下文内，形成领域模型。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界，边界之间用实线来表示 领域
这个边界内要解决的业务问题域.
在研究和解决业务问题时，DDD 会按照一定的规则将业务领域进行细分，当领域细分到一定的程度后，DDD 会将问题范围限定在特定的边界内，在这个边界内建立领域模型，进而用代码实现该领域模型，解决相应的业务问题
子域
我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围
核心域
决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力
通用域
没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域
支撑域
子域是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域.
限界上下文 Bounded Context
通用语言定义上下文含义，限界上下文则定义领域边界
通用语言
在事件风暴过程中，通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是通用语言
设计过程中我们可以用一些表格，来记录事件风暴和微服务设计过程中产生的领域对象及其属性
DDD 分析和设计过程中的每一个环节都需要保证限界上下文内术语的统一，在代码模型设计的时侯就要建立领域对象和代码对象的一一映射，从而保证业务模型和代码模型的一致，实现业务语言与代码语言的统一.
领域边界就是通过限界上下文来定义的.
我们将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案.
实体 Entity # 在 DDD 中有这样一类对象，它们拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体
实体和值对象是组成领域模型的基础单元.
实体的代码形态
充血模型 实体的运行形态
实体以 DO（领域对象）的形式存在，每个实体对象都有唯一的 ID. 值对象 ValueObject # 通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体.值对象本质上就是一个集.
在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计.
DDD 提倡从领域模型设计出发，而不是先设计数据模型.
聚合 Aggregate # 领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。
聚合根 AggregateRoot
如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。
聚合的构建过程 采用事件风暴，根据业务行为，梳理出在投保过程中发生这些行为的所有的实体和值对象，比如投保单、标的、客户、被保人等等。 从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体是否是聚合根，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一 ID？是否可以创建或修改其它对象？是否有专门的模块来管这个实体。图中的聚合根分别是投保单和客户实体。 根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值对象。构建出 1 个包含聚合根（唯一）、多个实体和值对象的对象集合，这个集合就是聚合。在图中我们构建了客户和投保这两个聚合。 在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。这里我需要说明一下：投保人和被保人的数据，是通过关联客户 ID 从客户聚合中获取的，在投保聚合里它们是投保单的值对象，这些值对象的数据是客户的冗余数据，即使未来客户聚合的数据发生了变更，也不会影响投保单的值对象数据。从图中我们还可以看出实体之间的引用关系，比如在投保聚合里投保单聚合根引用了报价单实体，报价单实体则引用了报价规则子实体。 多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。 聚合设计原则</description>
    </item>
    
  </channel>
</rss>
