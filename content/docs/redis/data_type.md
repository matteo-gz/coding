---
title: 数据类型
---
# 数据类型
- string
- hash
- list
- set
- sorted Set
- hyperLogLog
- Geo
- bitmap
- Stream
## 数据持久化
### RDB
Redis Database
会产生多个文件，每个文件代表某一个时刻的redis数据。对于aof来说，基于rdb恢复数据会更快。
### AOF
Append Only File
将每条写入命令写入日志中，在redis重启的时候通过日志文件重构数据

redis故障Rdb会丢失更多的数据，Rdb快照都是隔5分钟或者更长时间生成，而aof每隔一秒就会执行一次，所以只会丢失一秒钟的数据。

## 布隆过滤器

优点：优点很明显，二进制组成的数组，占用内存极少，并且插入和查询速度都足够快。

缺点：随着数据的增加，误判率会增加；还有无法判断数据一定存在；另外还有一个重要缺点，无法删除数据


## 场景
###  缓存击穿
- 逻辑检查,小于1 或者是字符串不允许之类的
- 使用布隆过滤器
- 缓存空对象,如果是网络恶意攻击（每次key不一样，且数据库不存在），缓存占用了更多的内存,缓存空对象要考虑到缓存时间的设置
### 缓存穿透
- 热数据永不过期
- 加上互斥锁
### 缓存雪崩
- 过期时间设置随机值
- 分布式部署且均匀分布热点数据
- 热数据永不过期
- 服务降级
- 服务熔断
- 请求限流
## redis高可用
- 主从复制 用于数据备份和读写分离
- 哨兵机制 自动故障转移提供高可用
- 集群机制 节点间数据同步和分区机制实现横向扩展和强一致性
## redis过期策略
- 定时删除:在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作
- 定期删除:每隔一段时间删除
- 惰性删除:获取的时候判断是否过期

Redis 选择「惰性删除+定期删除」这两种策略配和使用

## redis的内存淘汰机制
- noeviction: 当内存不足时，新写入操作会报错
- allkeys-lru：当内存不足时，移除最近最少使用的 key（这个是最常用的）。
- allkeys-random：当内存不足时，随机移除某个 key。
- volatile-lru：当内存不足时，在设置了过期时间的键中，移除最近最少使用的 key。
- volatile-random：当内存不足时，在设置了过期时间的键中，随机移除某个 key。
- volatile-ttl：当内存不足时，在设置了过期时间的键中，有更早过期时间的 key 优先移除。