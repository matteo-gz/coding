<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="极客时间.深入剖析 Kubernetes
容器基础 # 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个&quot;边界&quot;.
Cgroups 技术// 制造约束 Namespace 技术//修改进程视图 Namespace # 用来对各种不同的进程上下文进行“障眼法”操作
PID Mount UTS IPC Network User Cgroup // Linux 内核从 4.6 开始 PID namespace # 对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 多次执行上面的 clone(),就会创建多个 PID Namespace,每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况
障眼法 # Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时， Docker 为它们加上了各种各样的 Namespace 参数。
这时，这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程， 只能看到各自 Mount Namespace 里挂载的目录和文件， 只能访问到各自 Network Namespace 里的网络设备， 就仿佛运行在一个个“容器”里面，与世隔绝。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="k8s" />
<meta property="og:description" content="极客时间.深入剖析 Kubernetes
容器基础 # 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个&quot;边界&quot;.
Cgroups 技术// 制造约束 Namespace 技术//修改进程视图 Namespace # 用来对各种不同的进程上下文进行“障眼法”操作
PID Mount UTS IPC Network User Cgroup // Linux 内核从 4.6 开始 PID namespace # 对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 多次执行上面的 clone(),就会创建多个 PID Namespace,每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况
障眼法 # Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时， Docker 为它们加上了各种各样的 Namespace 参数。
这时，这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程， 只能看到各自 Mount Namespace 里挂载的目录和文件， 只能访问到各自 Network Namespace 里的网络设备， 就仿佛运行在一个个“容器”里面，与世隔绝。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://matteo-gz.github.io/coding/docs/ms/kubernetes/" /><meta property="article:section" content="docs" />


<title>k8s | Coding cheat sheet</title>
<link rel="manifest" href="/coding/manifest.json">
<link rel="icon" href="/coding/favicon.png" >
<link rel="stylesheet" href="/coding/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/coding/flexsearch.min.js"></script>
  <script defer src="/coding/en.search.min.ca27584bb505fe4f3bb7b408a6d00e5da0f3530606ee09a2e10ed328794bc3cc.js" integrity="sha256-yidYS7UF/k87t7QIptAOXaDzUwYG7gmi4Q7TKHlLw8w=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/coding/"><span>Coding cheat sheet</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>golang</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/chan/" class="">chan</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/defer/" class="">defer</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/gc/" class="">gc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/interface/" class="">interface</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/map/" class="">map</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/select/" class="">select</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/slice/" class="">slice</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/data_type/" class="">数据类型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/gmp/" class="">调度</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>mq</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mq/rabbitmq/" class="">rabbitmq</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mq/type/" class="">其他mq</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>mysql</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/b_tree/" class="">b &#43; 树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/count/" class="">count</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/ddl/" class="">ddl</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/delete/" class="">delete与truncate</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/transaction/" class="">事务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/log/" class="">日志</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/mysql_index/" class="">索引</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/lock/" class="">锁</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>nosql</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/nosql/mongodb/" class="">mongoDB</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>redis</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/redis/consistency/" class="">一致性风险</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/redis/lock/" class="">业务锁的选择</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/redis/data_type/" class="">数据类型</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>web</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/web/openresty/" class="">OpenResty</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>分布式</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/define/" class="">01. 分布式简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/coordination/" class="">02. 协调与同步</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/dt/" class="">02.1 分布式事务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/resource/" class="">03. 资源与负载</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/ds/" class="">03.1 分布式存储</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/distributed/" class="">BASE理论</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/etcd/" class="">etcd</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/raft-etcd/" class="">raft与etcd</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/saas/" class="">SaaS多租户存储设计</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>微服务</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/framework/" class="">Go框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/kubernetes/" class="active">k8s</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/k8s_network/" class="">k8s网络</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/kratos/" class="">kratos框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/discovery/" class="">服务发现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/ddd/" class="">领域驱动设计</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/coding/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>k8s</strong>

  <label for="toc-control">
    
    <img src="/coding/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#容器基础">容器基础</a>
      <ul>
        <li><a href="#namespace">Namespace</a></li>
        <li><a href="#pid-namespace">PID namespace</a></li>
        <li><a href="#障眼法">障眼法</a></li>
        <li><a href="#隔离得不彻底">隔离得不彻底</a></li>
        <li><a href="#linux-cgroups">Linux Cgroups</a></li>
        <li><a href="#mount">Mount</a></li>
        <li><a href="#联合文件系统">联合文件系统</a></li>
        <li><a href="#应用容器化">应用容器化</a></li>
        <li><a href="#volume">Volume</a></li>
      </ul>
    </li>
    <li><a href="#kubernetes的本质">Kubernetes的本质</a>
      <ul>
        <li><a href="#kubelet">kubelet</a></li>
        <li><a href="#kubeadm">kubeadm</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><blockquote>
<p><a href="https://time.geekbang.org/column/intro/100015201">极客时间.深入剖析 Kubernetes</a></p>
</blockquote>
<h2 id="容器基础">
  容器基础
  <a class="anchor" href="#%e5%ae%b9%e5%99%a8%e5%9f%ba%e7%a1%80">#</a>
</h2>
<p>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个&quot;边界&quot;.</p>
<ul>
<li>Cgroups 技术// 制造约束</li>
<li>Namespace 技术//修改进程视图</li>
</ul>
<h3 id="namespace">
  Namespace
  <a class="anchor" href="#namespace">#</a>
</h3>
<blockquote>
<p>用来对各种不同的进程上下文进行“障眼法”操作</p>
</blockquote>
<ul>
<li>PID</li>
<li>Mount</li>
<li>UTS</li>
<li>IPC</li>
<li>Network</li>
<li>User</li>
<li>Cgroup // Linux 内核从 4.6 开始</li>
</ul>
<h3 id="pid-namespace">
  PID namespace
  <a class="anchor" href="#pid-namespace">#</a>
</h3>
<blockquote>
<p>对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">clone</span>(main_function, stack_size, CLONE_NEWPID <span style="color:#f92672">|</span> SIGCHLD, NULL); 
</span></span></code></pre></div><blockquote>
<p>多次执行上面的 clone(),就会创建多个 PID Namespace,每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况</p>
</blockquote>
<h3 id="障眼法">
  障眼法
  <a class="anchor" href="#%e9%9a%9c%e7%9c%bc%e6%b3%95">#</a>
</h3>
<p>Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时，
Docker 为它们加上了各种各样的 Namespace 参数。</p>
<p>这时，这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程，
只能看到各自 Mount Namespace 里挂载的目录和文件，
只能访问到各自 Network Namespace 里的网络设备，
就仿佛运行在一个个“容器”里面，与世隔绝。</p>
<blockquote>
<p>Namespace 技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容</p>
</blockquote>
<p>&ldquo;敏捷&quot;和&quot;高性能&quot;是容器相较于虚拟机最大的优势.</p>
<h3 id="隔离得不彻底">
  隔离得不彻底
  <a class="anchor" href="#%e9%9a%94%e7%a6%bb%e5%be%97%e4%b8%8d%e5%bd%bb%e5%ba%95">#</a>
</h3>
<blockquote>
<p>容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核</p>
</blockquote>
<p><strong>行不通</strong></p>
<ul>
<li>Windows 宿主机上运行 Linux 容器</li>
<li>或者在低版本的 Linux 宿主机上运行高版本的 Linux 容器</li>
</ul>
<p>在 Linux 内核中，有很多资源和对象是<strong>不能被Namespace化</strong>的</p>
<p>比如<strong>时间</strong>.如果你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改</p>
<h3 id="linux-cgroups">
  Linux Cgroups
  <a class="anchor" href="#linux-cgroups">#</a>
</h3>
<blockquote>
<p>Linux 内核中用来为进程设置资源限制的一个重要功能</p>
</blockquote>
<p>Linux Cgroups 的全称是 Linux Control Group。
它最主要的作用，就是限制一个进程组能够使用的<strong>资源上限</strong>，包括 CPU、内存、磁盘、网络带宽等等.</p>
<p>Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合.</p>
<p>Linux Cgroups不足:/proc 文件系统.</p>
<h3 id="mount">
  Mount
  <a class="anchor" href="#mount">#</a>
</h3>
<p>Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知.</p>
<p>它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效.</p>
<p>Mount Namespace 正是基于对 chroot 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace.</p>
<p>而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：<strong>rootfs</strong>（根文件系统）</p>
<p>容器诞生</p>
<ol>
<li>启用 Linux Namespace 配置；</li>
<li>设置指定的 Cgroups 参数；</li>
<li>切换进程的根目录（Change Root）// 优先使用 pivot_root 系统调用.</li>
</ol>
<p>rootfs 只是一个操作系统所包含的文件、配置和目录，并<strong>不包括操作系统内核</strong>。
在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像.</p>
<p>正是由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：<strong>一致性</strong></p>
<p>由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，
应用以及它运行所需要的所有依赖，都被封装在了一起.</p>
<p><strong>对一个应用来说，操作系统本身才是它运行所需要的最完整的“依赖库”</strong>
<blockquote class="book-hint info">
  难道我每开发一个应用，或者升级一下现有的应用，都要重复制作一次 rootfs 吗？
</blockquote>

Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p>
<h3 id="联合文件系统">
  联合文件系统
  <a class="anchor" href="#%e8%81%94%e5%90%88%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f">#</a>
</h3>
<blockquote>
<p>联合文件系统（Union File System）,也叫 UnionFS. 最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下.</p>
</blockquote>
<h4 id="aufs">
  AuFS
  <a class="anchor" href="#aufs">#</a>
</h4>
<p>AuFS 的全称是 Another UnionFS，后改名为 Alternative UnionFS，再后来干脆改名叫作 Advance UnionFS，
从这些名字中你应该能看出这样两个事实：</p>
<ul>
<li>它是对 Linux 原生 UnionFS 的重写和改进；</li>
<li>它的作者怨气好像很大。我猜是 Linus Torvalds（Linux 之父）一直不让 AuFS 进入 Linux 内核主干的缘故，所以我们只能在 Ubuntu 和 Debian 这些发行版上使用它。</li>
</ul>
<blockquote>
<p>OverlayFS better than AuFS,AuFS 已经成为历史.</p>
</blockquote>
<p>分层</p>
<ul>
<li>只读层(ro+wh,readonly+whiteout)</li>
<li>Init 层 // 存放 /etc/hosts、/etc/resolv.conf 等信息</li>
<li>可读写层 // 一旦在容器里做了写操作，你修改产生的内容就会以<strong>增量</strong>的方式出现在这个层中.</li>
</ul>
<p>whiteout</p>
<blockquote>
<p>如果我现在要做的，是删除只读层里的一个文件呢？</p>
<p>为了实现这样的删除操作，AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来</p>
</blockquote>
<h3 id="应用容器化">
  应用容器化
  <a class="anchor" href="#%e5%ba%94%e7%94%a8%e5%ae%b9%e5%99%a8%e5%8c%96">#</a>
</h3>
<h4 id="制作容器镜像">
  制作容器镜像
  <a class="anchor" href="#%e5%88%b6%e4%bd%9c%e5%ae%b9%e5%99%a8%e9%95%9c%e5%83%8f">#</a>
</h4>
<p>Dockerfile 的设计思想，是使用一些标准的原语（即大写高亮的词语），描述我们所要构建的 Docker 镜像。
并且这些原语，都是按<strong>顺序</strong>处理的.</p>
<p>CMD 都是 Docker 容器进程启动所必需的参数，完整执行格式是：“ENTRYPOINT CMD”.
默认情况下，Docker 会为你提供一个隐含的 <strong>ENTRYPOINT</strong>，即：<code>/bin/sh -c</code>.</p>
<p><strong>Dockerfile 中的每个原语执行后，都会生成一个对应的镜像层</strong></p>
<p>docker exec 的实现原理</p>
<blockquote>
<p>一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的</p>
</blockquote>
<h4 id="network">
  Network
  <a class="anchor" href="#network">#</a>
</h4>
<p>Docker 还专门提供了一个参数，可以让你启动一个容器并“加入”到另一个容器的 Network Namespace 里，这个参数就是 -net</p>
<p>–net=host，就意味着这个容器不会为进程启用 Network Namespace。这就意味着，
这个容器拆除了 Network Namespace 的“隔离墙”，所以，它会和宿主机上的其他普通进程一样，直接<strong>共享宿主机的网络栈</strong>。
这就为容器直接操作和使用宿主机网络提供了一个渠道。</p>
<h3 id="volume">
  Volume
  <a class="anchor" href="#volume">#</a>
</h3>
<p>Volume 机制解决问题</p>
<ul>
<li>容器里进程新建的文件，怎么才能让宿主机获取到？</li>
<li>宿主机上的文件和目录，怎么才能让容器里的进程访问到？</li>
</ul>
<blockquote>
<p>允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作</p>
</blockquote>
<p>执行挂载操作时，“容器进程”已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见容器内部的这个挂载点的。这就<strong>保证了容器的隔离性不会被 Volume 打破</strong></p>
<blockquote>
<p>注意：这里提到的 &quot; 容器进程 &ldquo;，是 Docker 创建的一个容器初始化进程 (dockerinit)，而不是应用进程 (ENTRYPOINT + CMD)。dockerinit 会负责完成根目录的准备、挂载设备和目录、配置 hostname 等一系列需要在容器内进行的初始化操作。最后，它通过 execv() 系统调用，让应用进程取代自己，成为容器里的 PID=1 的进程。</p>
</blockquote>
<p>Linux 的绑定挂载（bind mount）机制</p>
<blockquote>
<p>它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响</p>
</blockquote>
<p>在一个正确的时机，进行一次绑定挂载，Docker 就可以成功地将一个宿主机上的目录或文件，不动声色地挂载到容器中.</p>
<p><code>docker run -d -v /test helloworld</code></p>
<blockquote>
<p>容器 Volume 里的信息，并不会被 docker commit 提交掉；但这个挂载点目录 /test 本身，则会出现在新的镜像当中.</p>
</blockquote>
<h2 id="kubernetes的本质">
  Kubernetes的本质
  <a class="anchor" href="#kubernetes%e7%9a%84%e6%9c%ac%e8%b4%a8">#</a>
</h2>
<p>一个正在运行的 Linux 容器</p>
<ul>
<li>一组联合挂载在 /var/lib/docker/aufs/mnt 上的 rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；</li>
<li>一个由 Namespace+Cgroups 构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。</li>
</ul>
<p>容器就从一个开发者手里的小工具，一跃成为了云计算领域的绝对主角；而能够定义容器组织和管理规范的“<strong>容器编排</strong>”技术，则当仁不让地坐上了容器技术领域的“头把交椅”.</p>
<p>k8s架构图
<img src="../k1.png" alt="" /></p>
<p>节点</p>
<ul>
<li>Master 控制节点
<ul>
<li>API 服务 kube-apiserver</li>
<li>负责调度 kube-scheduler</li>
<li>负责容器编排 kube-controller-manager</li>
<li>整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中</li>
</ul>
</li>
<li>Node 计算节点
<ul>
<li>kubelet <strong>负责同容器运行时（比如 Docker 项目）打交道</strong></li>
</ul>
</li>
</ul>
<h3 id="kubelet">
  kubelet
  <a class="anchor" href="#kubelet">#</a>
</h3>
<p>kubelet交互所依赖的，是一个称作 CRI（Container Runtime Interface）的远程调用接口，
这个接口定义了容器运行时的各项核心操作，比如：启动一个容器需要的所有参数.</p>
<ul>
<li>通过 gRPC 协议同一个叫作 Device Plugin 的插件进行交互
<ul>
<li>接口为CNI（Container Networking Interface）</li>
</ul>
</li>
<li>调用网络插件和存储插件为容器配置网络和持久化存储
<ul>
<li>接口为CSI（Container Storage Interface）</li>
</ul>
</li>
</ul>
<p>观点:</p>
<blockquote>
<p>运行在大规模集群中的各种任务之间，实际上存在着各种各样的关系。这些关系的处理，才是作业编排和管理系统最困难的地方。</p>
</blockquote>
<p>Kubernetes 项目最主要的<strong>设计思想</strong>是，<strong>从更宏观的角度</strong>，以统一的方式来定义任务之间的各种关系，并且为将来支持更多种类的关系留有余地</p>
<p>Service 服务的主要作用，就是作为 Pod 的代理入口（Portal），从而代替 Pod 对外暴露一个固定的网络地址</p>
<p><img src="../k2.png" alt="" /></p>
<p><strong>除了应用与应用之间的关系外，应用运行的形态是影响“如何容器化这个应用”的第二个重要因素。</strong></p>
<p>在 Kubernetes 项目中，我们所推崇的使用方法是：</p>
<ul>
<li>首先，通过一个“编排对象”，比如 Pod、Job、CronJob 等，来描述你试图管理的应用；</li>
<li>然后，再为它定义一些“服务对象”，比如 Service、Secret、Horizontal Pod Autoscaler（自动水平扩展器）等。这些对象，会负责具体的平台级功能。</li>
</ul>
<p>这种使用方法，就是所谓的“<strong>声明式 API</strong>”。这种 API 对应的“编排对象”和“服务对象”，都是 Kubernetes 项目中的 API 对象（API Object）。</p>
<h3 id="kubeadm">
  kubeadm
  <a class="anchor" href="#kubeadm">#</a>
</h3>
<blockquote>
<p>让用户能够通过这样两条指令完成一个 Kubernetes 集群的部署</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 创建一个 Master 节点</span>
</span></span><span style="display:flex;"><span>$ kubeadm init
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 将一个 Node 节点加入到当前集群中</span>
</span></span><span style="display:flex;"><span>$ kubeadm join &lt;Master 节点的 IP 和端口 &gt;
</span></span></code></pre></div><blockquote>
<p>把 kubelet 直接运行在宿主机上，然后使用容器部署其他的 Kubernetes 组件。</p>
</blockquote>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#容器基础">容器基础</a>
      <ul>
        <li><a href="#namespace">Namespace</a></li>
        <li><a href="#pid-namespace">PID namespace</a></li>
        <li><a href="#障眼法">障眼法</a></li>
        <li><a href="#隔离得不彻底">隔离得不彻底</a></li>
        <li><a href="#linux-cgroups">Linux Cgroups</a></li>
        <li><a href="#mount">Mount</a></li>
        <li><a href="#联合文件系统">联合文件系统</a></li>
        <li><a href="#应用容器化">应用容器化</a></li>
        <li><a href="#volume">Volume</a></li>
      </ul>
    </li>
    <li><a href="#kubernetes的本质">Kubernetes的本质</a>
      <ul>
        <li><a href="#kubelet">kubelet</a></li>
        <li><a href="#kubeadm">kubeadm</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












