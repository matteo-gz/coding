<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="极客时间.分布式技术原理与算法解析 笔记
分布式互斥 # 在分布式系统里，排他性的资源访问方式，叫作分布式互斥（Distributed Mutual Exclusion）， 而这种被互斥访问的共享资源就叫作临界资源（Critical Resource）
集中式算法 # 协调者参与
graph TB subgraph 分布式系统 A[程序 A] --&gt; C[协调者] B[程序 B] --&gt; C[协调者] end subgraph 互斥算法 C[协调者] --&gt; D[发送请求] D --&gt; E[检查资源状态] E --&gt; |资源空闲| F[授权访问] E --&gt; |资源占用| G[排号等待] G --&gt; H[接收通知] H --&gt; D F --&gt; I[访问资源] I --&gt; J[释放资源] J --&gt; |通知协调者| C end 优点
开发和实现简单,不存在节点间的协调问题 数据一致性易于控制 故障修复相对简单 缺点
可靠性和性能依赖于中心节点 中心节点出故障或压力过大会导致整体服务挂掉 难以水平扩展以提升吞吐量 分布式算法 # 定义">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="02. 协调与同步" />
<meta property="og:description" content="极客时间.分布式技术原理与算法解析 笔记
分布式互斥 # 在分布式系统里，排他性的资源访问方式，叫作分布式互斥（Distributed Mutual Exclusion）， 而这种被互斥访问的共享资源就叫作临界资源（Critical Resource）
集中式算法 # 协调者参与
graph TB subgraph 分布式系统 A[程序 A] --&gt; C[协调者] B[程序 B] --&gt; C[协调者] end subgraph 互斥算法 C[协调者] --&gt; D[发送请求] D --&gt; E[检查资源状态] E --&gt; |资源空闲| F[授权访问] E --&gt; |资源占用| G[排号等待] G --&gt; H[接收通知] H --&gt; D F --&gt; I[访问资源] I --&gt; J[释放资源] J --&gt; |通知协调者| C end 优点
开发和实现简单,不存在节点间的协调问题 数据一致性易于控制 故障修复相对简单 缺点
可靠性和性能依赖于中心节点 中心节点出故障或压力过大会导致整体服务挂掉 难以水平扩展以提升吞吐量 分布式算法 # 定义" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://matteo-gz.github.io/coding/docs/distributed/coordination/" /><meta property="article:section" content="docs" />


<title>02. 协调与同步 | Coding cheat sheet</title>
<link rel="manifest" href="/coding/manifest.json">
<link rel="icon" href="/coding/favicon.png" >
<link rel="stylesheet" href="/coding/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/coding/flexsearch.min.js"></script>
  <script defer src="/coding/en.search.min.ca27584bb505fe4f3bb7b408a6d00e5da0f3530606ee09a2e10ed328794bc3cc.js" integrity="sha256-yidYS7UF/k87t7QIptAOXaDzUwYG7gmi4Q7TKHlLw8w=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/coding/"><span>Coding cheat sheet</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>golang</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/chan/" class="">chan</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/defer/" class="">defer</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/gc/" class="">gc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/interface/" class="">interface</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/map/" class="">map</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/select/" class="">select</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/slice/" class="">slice</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/data_type/" class="">数据类型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/go/gmp/" class="">调度</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>mq</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mq/rabbitmq/" class="">rabbitmq</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mq/type/" class="">其他mq</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>mysql</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/b_tree/" class="">b &#43; 树</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/count/" class="">count</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/ddl/" class="">ddl</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/delete/" class="">delete与truncate</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/transaction/" class="">事务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/log/" class="">日志</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/mysql_index/" class="">索引</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/mysql/lock/" class="">锁</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>nosql</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/nosql/mongodb/" class="">mongoDB</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>redis</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/redis/consistency/" class="">一致性风险</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/redis/lock/" class="">业务锁的选择</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/redis/data_type/" class="">数据类型</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>web</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/web/openresty/" class="">OpenResty</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>分布式</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/define/" class="">01. 分布式简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/coordination/" class="active">02. 协调与同步</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/dt/" class="">02.1 分布式事务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/resource/" class="">03. 资源与负载</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/ds/" class="">03.1 分布式存储</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/distributed/" class="">BASE理论</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/etcd/" class="">etcd</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/raft-etcd/" class="">raft与etcd</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/distributed/saas/" class="">SaaS多租户存储设计</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>微服务</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/framework/" class="">Go框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/kubernetes/" class="">k8s</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/k8s_network/" class="">k8s网络</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/kratos/" class="">kratos框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/discovery/" class="">服务发现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/coding/docs/ms/ddd/" class="">领域驱动设计</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/coding/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>02. 协调与同步</strong>

  <label for="toc-control">
    
    <img src="/coding/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#分布式互斥">分布式互斥</a>
      <ul>
        <li><a href="#集中式算法">集中式算法</a></li>
        <li><a href="#分布式算法">分布式算法</a></li>
        <li><a href="#令牌环算法">令牌环算法</a></li>
        <li><a href="#分布式互斥作用">分布式互斥作用</a></li>
      </ul>
    </li>
    <li><a href="#分布式选举">分布式选举</a>
      <ul>
        <li><a href="#bully-算法">Bully 算法</a></li>
        <li><a href="#raft-算法">Raft 算法</a></li>
        <li><a href="#zab-算法">ZAB 算法</a></li>
        <li><a href="#选举对比">选举对比</a></li>
      </ul>
    </li>
    <li><a href="#分布式共识">分布式共识</a>
      <ul>
        <li><a href="#pow">PoW</a></li>
        <li><a href="#pos">PoS</a></li>
        <li><a href="#dpos">DPoS</a></li>
        <li><a href="#拜占庭将军问题">拜占庭将军问题</a></li>
      </ul>
    </li>
    <li><a href="#分布式锁">分布式锁</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><blockquote>
<p><a href="https://time.geekbang.org/column/intro/100036401">极客时间.分布式技术原理与算法解析</a> 笔记</p>
</blockquote>
<h2 id="分布式互斥">
  分布式互斥
  <a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%92%e6%96%a5">#</a>
</h2>
<p>在分布式系统里，排他性的资源访问方式，叫作<strong>分布式互斥</strong>（Distributed Mutual Exclusion），
而这种被互斥访问的共享资源就叫<strong>作临界资源</strong>（Critical Resource）</p>
<h3 id="集中式算法">
  集中式算法
  <a class="anchor" href="#%e9%9b%86%e4%b8%ad%e5%bc%8f%e7%ae%97%e6%b3%95">#</a>
</h3>
<p>协调者参与</p>


<script src="/coding/mermaid.min.js"></script>

  <script>mermaid.initialize({
  "flowchart": {
    "useMaxWidth":true
  },
  "theme": "default"
}
)</script>




<p class="mermaid">
graph TB

subgraph 分布式系统
A[程序 A] --> C[协调者]
B[程序 B] --> C[协调者]
end

subgraph 互斥算法
C[协调者] --> D[发送请求]
D --> E[检查资源状态]
E --> |资源空闲| F[授权访问]
E --> |资源占用| G[排号等待]
G --> H[接收通知]
H --> D
F --> I[访问资源]
I --> J[释放资源]
J --> |通知协调者| C
end
</p>

<p>优点</p>
<ul>
<li>开发和实现简单,不存在节点间的协调问题</li>
<li>数据一致性易于控制</li>
<li>故障修复相对简单</li>
</ul>
<p>缺点</p>
<ul>
<li>可靠性和性能依赖于中心节点</li>
<li>中心节点出故障或压力过大会导致整体服务挂掉</li>
<li>难以水平扩展以提升吞吐量</li>
</ul>
<h3 id="分布式算法">
  分布式算法
  <a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%ae%97%e6%b3%95">#</a>
</h3>
<p>定义</p>
<blockquote>
<p>当一个程序要访问临界资源时，先向系统中的其他程序发送一条请求消息，在接收到所有程序返回的同意消息后，才可以访问临界资源。其中，请求消息需要包含所请求的资源、请求者的 ID，以及发起请求的时间</p>
</blockquote>


<p class="mermaid">
sequenceDiagram
actor 程序1
actor 程序2
actor 程序3

程序1->>程序2: 请求访问资源A
程序1->>程序3: 请求访问资源A
程序2-->>程序1: 同意
程序3-->>程序1: 同意

程序3->>程序1: 请求访问资源A
程序3->>程序2: 请求访问资源A
程序2-->>程序3: 同意
Note over 程序3: 等待程序1使用完
程序1-->>程序3: 同意

程序1->>资源A: 使用资源A
程序1-->>资源A: 释放资源A

程序3->>资源A: 使用资源A
程序3-->>资源A: 释放资源A
</p>

<p>在大型系统中使用分布式算法，消息数量会随着需要访问临界资源的程序数量呈指数级增加，容易导致高昂的&quot;<strong>沟通成本</strong>&quot;。</p>
<p>分布式算法适合<strong>节点数目少</strong>且<strong>变动不频繁</strong>的系统，且由于每个程序均需通信交互，因此适合 P2P 结构的系统.</p>
<h4 id="hadoop">
  Hadoop
  <a class="anchor" href="#hadoop">#</a>
</h4>
<p>HDFS 的文件修改


<p class="mermaid">

sequenceDiagram
participant 计算机 1
participant 计算机 2
participant 计算机 3
计算机 1 ->> 计算机 2: 发送文件修改请求
计算机 1 ->> 计算机 3: 发送文件修改请求
计算机 2 -->> 计算机 1: 同意请求
计算机 3 -->> 计算机 1: 同意请求
计算机 1 ->> D文件: 开始修改文件
D文件 -->> 计算机 1: 修改完成
计算机 1 ->> 计算机 2: 发送修改完成消息和文件数据
计算机 1 ->> 计算机 3: 发送修改完成消息和文件数据
计算机 2 ->> E文件: 接收文件数据
计算机 3 ->> F文件: 接收文件数据

</p>
</p>
<p>分布式算法是一个“先到先得&quot;和“投票全票通过&quot;的公平访问机制，但通信成本较高，可用性也比集中式算法低，适用于临界资源使用频度较低，且系统规模较小的场景.</p>
<h3 id="令牌环算法">
  令牌环算法
  <a class="anchor" href="#%e4%bb%a4%e7%89%8c%e7%8e%af%e7%ae%97%e6%b3%95">#</a>
</h3>
<p>

<p class="mermaid">
graph TD
A -- 拥有令牌时访问 --> 资源
B -- 拥有令牌时访问 --> 资源
C -- 拥有令牌时访问 --> 资源 
D -- 拥有令牌时访问 --> 资源

A -. 传递令牌 .-> B
B -. 传递令牌 .-> C
C -. 传递令牌 .-> D
D -. 传递令牌 .-> A
</p>

令牌环算法的公平性高，在改进单点故障后，稳定性也很高，适用于系统规模较小，并且系统中每个程序使用临界资源的<strong>频率高且使用时间比较短</strong>的场景.</p>
<h3 id="分布式互斥作用">
  分布式互斥作用
  <a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%92%e6%96%a5%e4%bd%9c%e7%94%a8">#</a>
</h3>
<ul>
<li>保证资源的独占性访问</li>
<li>并发控制</li>
</ul>
<p>传统单机上的互斥方法，为什么不能用于分布式环境呢？</p>
<blockquote>
<p>传统单机上的互斥方法,例如mutex锁,不能直接用于分布式环境主要有以下几个原因:</p>
<p>分布式环境下,进程/线程在不同主机上运行,无法直接访问<strong>共享内存</strong>区域进行锁操作。
互斥锁依赖于共享内存模型无法实现。</p>
<p>不同主机上的时钟不一定同步,无法判断锁的持有时间。
互斥锁依赖于同步<strong>时钟</strong>实现锁定策略。</p>
<p>不同主机之间的<strong>通信开销</strong>很高,每次获取锁或释放锁都需要网络传输,性能很差。</p>
<p>分布式系统里<strong>硬件错误</strong>或<strong>网络故障</strong>很常见,单一锁持有者可能crash掉从而阻塞其他进程。缺乏容错能力。</p>
<p>分布式系统中加入和退出节点很动态,锁机制需要能够<strong>自动适应节点</strong>变化。</p>
<p>不同数据中心的节点需要协调进行锁操作,但网络延迟非常高。</p>
<p>分布式环境需要使用额外的技术如共识算法、消息传递等来实现分布式锁,
可以在不同节点间进行通信和协调,获得更强的一致性和可扩展性。</p>
</blockquote>
<h2 id="分布式选举">
  分布式选举
  <a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e9%80%89%e4%b8%be">#</a>
</h2>
<p>选举的作用</p>
<blockquote>
<p>选出一个主节点，由它来协调和管理其他节点，以保证集群有序运行和节点间数据的<strong>一致性</strong>.</p>
</blockquote>
<p>选举算法</p>
<ul>
<li>基于序号选举的算法
<ul>
<li>Bully 算法</li>
</ul>
</li>
<li>多数派算法
<ul>
<li>Raft 算法</li>
<li>ZAB 算法</li>
</ul>
</li>
</ul>
<h3 id="bully-算法">
  Bully 算法
  <a class="anchor" href="#bully-%e7%ae%97%e6%b3%95">#</a>
</h3>
<p>选举原则</p>
<ul>
<li>在所有活着的节点中，选取 ID 最大的节点作为主节点.</li>
</ul>
<p>前提</p>
<blockquote>
<p>集群中每个节点均知道其他节点的 ID.</p>
</blockquote>
<p>

<p class="mermaid">
graph LR
A[节点 A]
B[节点 B]
C[节点 C]
D[节点 D-故障]

B -->|1. Election| D
B -->|1. Election| C
C -->|2. Alive| B
C -->|3. Election| D
C -->|4. Victory| B
C -->|4. Victory| A

</p>

消息类型</p>
<ul>
<li>Election 消息，用于发起选举</li>
<li>Alive 消息，对 Election 消息的应答</li>
<li>Victory 消息，竞选成功的主节点向其他节点发送的宣誓主权的消息</li>
</ul>
<p>流程</p>
<ol>
<li>集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权；</li>
<li>如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送 Election 消息，并等待其他节点的回复；</li>
<li>若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己 ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；</li>
<li>若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。</li>
</ol>
<p>优点</p>
<ul>
<li>选举速度快</li>
<li>算法复杂度低</li>
<li>简单易实现</li>
</ul>
<p>缺点</p>
<ul>
<li>每个节点有全局的节点信息</li>
<li>任意一个比当前主节点 ID 大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主</li>
</ul>
<h3 id="raft-算法">
  Raft 算法
  <a class="anchor" href="#raft-%e7%ae%97%e6%b3%95">#</a>
</h3>
<h3 id="zab-算法">
  ZAB 算法
  <a class="anchor" href="#zab-%e7%ae%97%e6%b3%95">#</a>
</h3>
<p>ZAB（ZooKeeper Atomic Broadcast）选举算法</p>
<blockquote>
<p>是为 ZooKeeper 实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。相比较于 Raft 算法，ZAB 算法尽可能保证数据的最新性。所以，ZAB 算法可以说是对 Raft 算法的改进</p>
</blockquote>
<table>
<thead>
<tr>
<th>状态</th>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Looking</td>
<td>选举</td>
<td>当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态</td>
</tr>
<tr>
<td>Leading</td>
<td>领导</td>
<td>表示已经选出主，且当前节点为 Leader</td>
</tr>
<tr>
<td>Following</td>
<td>跟随</td>
<td>集群中已经选出主后，其他非主节点状态更新为 Following，表示对 Leader 的追随</td>
</tr>
<tr>
<td>Observing</td>
<td>观察</td>
<td>表示当前节点为 Observer，持观望态度，没有投票权和选举权</td>
</tr>
</tbody>
</table>
<p>核心</p>
<ul>
<li>少数服从多数，ID 大的节点优先成为主</li>
</ul>
<p>ZAB 算法性能高，对系统无特殊要求，采用广播方式发送信息，若节点中有 n 个节点，每个节点同时广播，则集群中信息量为 n*(n-1) 个消息，容易出现<strong>广播风暴</strong>；</p>
<p>且除了投票，还增加了对比节点 ID 和数据 ID，这就意味着还需要知道所有节点的 ID 和数据 ID，所以<strong>选举时间相对较长</strong>。</p>
<p>但该算法选举<strong>稳定性比较好</strong>，当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点数据 ID 和节点 ID 最大，且获得投票数过半，才会导致切主。</p>
<h3 id="选举对比">
  选举对比
  <a class="anchor" href="#%e9%80%89%e4%b8%be%e5%af%b9%e6%af%94">#</a>
</h3>
<table>
<thead>
<tr>
<th></th>
<th>Bully</th>
<th>Raft</th>
<th>ZAB</th>
</tr>
</thead>
<tbody>
<tr>
<td>选举原则</td>
<td>节点ID最大</td>
<td>投票最多</td>
<td>数据最新或ID最大</td>
</tr>
<tr>
<td>优点</td>
<td>容易理解,选举速度快,算法复杂度低,易于实现</td>
<td>选举速度快,算法复杂度低,易于实现</td>
<td>性能高</td>
</tr>
<tr>
<td>缺点</td>
<td>信心存储量大,易频繁切主,不适大规模</td>
<td>要求系统全连接,消息通信量大,不适大规模</td>
<td>选举时间长,复杂度高</td>
</tr>
<tr>
<td>应用场景</td>
<td>适合小规模,MongoDB</td>
<td>适合中小规模,K8S集群中3个节点选举</td>
<td>适合中大规模,Zookeeper</td>
</tr>
</tbody>
</table>
<h2 id="分布式共识">
  分布式共识
  <a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e5%85%b1%e8%af%86">#</a>
</h2>
<blockquote>
<p>分布式共识就是在多个节点均可独自操作或记录的情况下，使得所有节点针对某个状态达成一致的过程</p>
</blockquote>
<p>下文以区块链技术共识机制举例.</p>
<p>解决方式</p>
<ul>
<li>PoW // Proof-of-Work，工作量证明</li>
<li>PoS // Proof-of-Stake，权益证明</li>
<li>DPoS // Delegated Proof of Stake，委托权益证明</li>
</ul>
<p>分布式共识核心</p>
<ul>
<li>记账权</li>
<li>所有节点或服务器达成一致</li>
</ul>
<h3 id="pow">
  PoW
  <a class="anchor" href="#pow">#</a>
</h3>
<blockquote>
<p>是以每个节点或服务器的计算能力（即“算力”）来竞争记账权的机制，因此是一种使用工作量证明机制的共识算法</p>
</blockquote>
<p>PoW 的容错机制,允许全网 50% 的节点出错.缺点是共识达成的周期长、效率低，资源消耗大.</p>
<p>共识的时间影响因素</p>
<ul>
<li>PoW 机制每次达成共识需要全网共同参与运算，增加了每个节点的计算量.</li>
<li>如果题目过难，会导致计算时间长、资源消耗多.</li>
<li>如果题目过于简单，会导致大量节点同时获得记账权，冲突多.</li>
</ul>
<h3 id="pos">
  PoS
  <a class="anchor" href="#pos">#</a>
</h3>
<blockquote>
<p>核心原理:由系统权益代替算力来决定区块记账权，拥有的权益越大获得记账权的概率就越大</p>
</blockquote>
<p>缩短了达成共识时间,但容易出现垄断现象.</p>
<h3 id="dpos">
  DPoS
  <a class="anchor" href="#dpos">#</a>
</h3>
<blockquote>
<p>DPoS 算法的原理，类似股份制公司的董事会制度，普通股民虽然拥有股权，但进不了董事会，他们可以投票选举代表（受托人）代他们做决策。DPoS 是由被社区选举的可信帐户（受托人，比如得票数排行前 101 位）来拥有记账权。</p>
</blockquote>
<p>缺点:</p>
<ul>
<li>持币人投票积极性不高.</li>
<li>故障问题解决效率低,易出现安全隐患.</li>
</ul>
<h3 id="拜占庭将军问题">
  拜占庭将军问题
  <a class="anchor" href="#%e6%8b%9c%e5%8d%a0%e5%ba%ad%e5%b0%86%e5%86%9b%e9%97%ae%e9%a2%98">#</a>
</h3>
<blockquote>
<p>假设一支军队由多个将军组成，这些将军需要就进攻或撤退的决策达成共识。然而，一些将军可能是不可信的，他们可能发送虚假的消息或者完全拒绝发送消息。此外，将军之间的通信可能会受到敌人的干扰，导致消息被篡改或丢失</p>
</blockquote>
<p>人数比例</p>
<blockquote>
<p>如果叛将人数为 <strong>m</strong>，将军人数不能少于 <strong>3m + 1</strong> ，那么拜占庭将军问题就能解决了. <a href="https://lamport.azurewebsites.net/pubs/byz.pdf">The Byzantine Generals Problem by Leslie Lamport</a></p>
</blockquote>
<p>消息签名机制防伪</p>
<h2 id="分布式锁">
  分布式锁
  <a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81">#</a>
</h2>
<blockquote>
<p>锁是实现多线程同时访问同一共享资源，保证同一时刻只有一个线程可访问共享资源所做的一种标记</p>
</blockquote>
<p>主流方法</p>
<ul>
<li>关系型数据库实现分布式锁 // 适用于并发量低，对性能要求低的场景</li>
<li>cache实现分布式锁 // 利用SetNX原子操作,但锁失效时间控制不稳定</li>
<li>ZooKeeper实现分布式锁 // 可靠性最高</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#分布式互斥">分布式互斥</a>
      <ul>
        <li><a href="#集中式算法">集中式算法</a></li>
        <li><a href="#分布式算法">分布式算法</a></li>
        <li><a href="#令牌环算法">令牌环算法</a></li>
        <li><a href="#分布式互斥作用">分布式互斥作用</a></li>
      </ul>
    </li>
    <li><a href="#分布式选举">分布式选举</a>
      <ul>
        <li><a href="#bully-算法">Bully 算法</a></li>
        <li><a href="#raft-算法">Raft 算法</a></li>
        <li><a href="#zab-算法">ZAB 算法</a></li>
        <li><a href="#选举对比">选举对比</a></li>
      </ul>
    </li>
    <li><a href="#分布式共识">分布式共识</a>
      <ul>
        <li><a href="#pow">PoW</a></li>
        <li><a href="#pos">PoS</a></li>
        <li><a href="#dpos">DPoS</a></li>
        <li><a href="#拜占庭将军问题">拜占庭将军问题</a></li>
      </ul>
    </li>
    <li><a href="#分布式锁">分布式锁</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












