<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mysql on Coding cheat sheet</title>
    <link>https://matteo-gz.github.io/coding/docs/mysql/</link>
    <description>Recent content in mysql on Coding cheat sheet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://matteo-gz.github.io/coding/docs/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>b &#43; 树</title>
      <link>https://matteo-gz.github.io/coding/docs/mysql/b_tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/mysql/b_tree/</guid>
      <description>为什么 MySQL 采用 B+ 树作为索引?
树结构的对比种类 # 二叉查找树 平衡二叉查找树 B tree B + tree 二叉查找树 # 二叉查找树(Binary Search Tree)的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点
查询和插入删除效率较高,但平衡性不佳,最坏情况下时间复杂度为O(n)
当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)
遍历 # 先序遍历按照“根节点-&amp;gt;左子树-&amp;gt;右子树”的顺序进行遍历 中序遍历按照“左子树-&amp;gt;根节点-&amp;gt;右子树”的顺序进行遍历 后序遍历按照“左子树-&amp;gt;右子树-&amp;gt;根结点”的顺序进行遍历 平衡二叉查找树 # AVL树为实现平衡二叉查找树的数据结构
每个节点的左子树和右子树的高度差不能超过 1
时间复杂度降低到O(log n)
不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率
B tree # 当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度
B + tree # B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少
B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助</description>
    </item>
    
    <item>
      <title>count</title>
      <link>https://matteo-gz.github.io/coding/docs/mysql/count/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/mysql/count/</guid>
      <description> count(1) and count(*) # count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略NULL
count(1) and count(列名) # count(1) 会统计表中的所有的记录数，不会忽略NULL，包含字段为null 的记录 count(列名) 会统计该列字段在表中出现的次数，会忽略字段为null 的情况，即不统计字段为null 的记录 执行效率 # 若列名为主键，count(列名)会比count(1)快 若列名不为主键，count(1)会比count(列名)快 若表多个列并且没有主键，则 count（1） 的执行效率优于 count（*） 若表有主键，则 select count（主键）的执行效率是最优的 若表只有一个字段，则 select count（*）最优。 优先使用count(*)或count(主键id);若主键不能用,则用count(1);若都不行才使用count(字段)
如何优化 count(*)？ # 近似值,explain 命令来表进行估算 额外表保存计数值 </description>
    </item>
    
    <item>
      <title>ddl</title>
      <link>https://matteo-gz.github.io/coding/docs/mysql/ddl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/mysql/ddl/</guid>
      <description>DDL # MySQL DDL(Data Definition Language)的是MySQL数据库的数据定义语言,用于定义和管理数据库对象,如数据库、表、列等。
主要的MySQL DDL语句包括:
CREATE:用于创建数据库对象,如创建数据库、表等。比如CREATE DATABASE、CREATE TABLE。
ALTER:用于修改数据库对象的结构或属性,如ALTER TABLE修改表结构。
DROP:用于删除数据库对象,如DROP DATABASE删除数据库,DROP TABLE删除表。
TRUNCATE:清空表中的所有行而不删除表本身。
RENAME:用来重命名数据库对象,如RENAME TABLE重命名表。
COMMENT:为数据库对象添加注释,如COMMENT ON TABLE为表添加注释。
INDEX:创建和删除数据库索引,如CREATE INDEX添加索引,DROP INDEX删除索引。
其他类似 # DML(Data Manipulation Language) # 数据操作语言,用于对数据记录进行增删改操作,比如INSERT、UPDATE、DELETE等语句。
DQL(Data Query Language) # 数据查询语言,用于对数据库进行选择和查询,主要是SELECT语句。
DCL(Data Control Language) # 数据控制语言,用于控制数据库访问权限,如GRANT和REVOKE语句。
TCL(Transaction Control Language) # 事务控制语言,用于管理数据库事务,如COMMIT、ROLLBACK、SAVEPOINT语句。
DAL(Data Analysis Language) # 数据分析语言,用于对数据库进行统计和分析计算,如COUNT、SUM、AVG函数等。
DSL(Data Definition Language) # 数据定义语言,用于定义数据库索引与视图等,如CREATE INDEX和CREATE VIEW语句。</description>
    </item>
    
    <item>
      <title>delete与truncate</title>
      <link>https://matteo-gz.github.io/coding/docs/mysql/delete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/mysql/delete/</guid>
      <description>速度:drop &amp;gt; truncate &amp;gt; DELETE
DML:delete DDL:drop,truncate
DELETE:删除表中的某些行,但不删除表结构。删除后数据行数减少,但表还存在。 TRUNCATE:清空表内所有数据,但不删除表结构。与DELETE不同的是,TRUNCATE没有事务日志,效率更高。 DROP:完全删除表,表结构和表数据一起删除。删除后无法恢复。 可以这么理解，一本书，delete是把目录撕了，truncate是把书的内容撕下来烧了，drop是把书烧了</description>
    </item>
    
    <item>
      <title>事务</title>
      <link>https://matteo-gz.github.io/coding/docs/mysql/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/mysql/transaction/</guid>
      <description>事务特性 # 原子性 atomicity 一致性 consistency 隔离性 isolation 持久性 durability 如何保证事务特性?
持久性是通过 redo log （重做日志）来保证的； 原子性是通过 undo log（回滚日志） 来保证的； 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的； 一致性则是通过持久性+原子性+隔离性来保证； 并发问题 # 脏读 # 如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象
不可重复读 # 在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。
幻读 # 在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。
事务隔离级别 # read uncommitted 读未提及 # 可能发生脏读、不可重复读和幻读现象
read committed 读已提交 # 可能发生不可重复读和幻读现象
repeatable read 可重复读 # 可能发生幻读现象
MySQL InnoDB 引擎的默认隔离级别
serializable 串行化 # MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象
针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。 针对当前读（select &amp;hellip; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select &amp;hellip; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。 MVCC # multi-version concurrency control,多版本并发控制</description>
    </item>
    
    <item>
      <title>日志</title>
      <link>https://matteo-gz.github.io/coding/docs/mysql/log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/mysql/log/</guid>
      <description> undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。 redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复； binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制； relay log ,一般情况下它在MySQL主从同步读写分离集群的从节点才开启。主节点一般不需要这个日志。 </description>
    </item>
    
    <item>
      <title>索引</title>
      <link>https://matteo-gz.github.io/coding/docs/mysql/mysql_index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/mysql/mysql_index/</guid>
      <description>指定索引 # 使用FORCE INDEX关键字强制使用指定的索引,强制使用指定的索引
SELECT * FROM table FORCE INDEX (index_name) WHERE condition; 使用USE INDEX关键字建议使用指定索引,优先使用指定的索引
SELECT * FROM table USE INDEX (index_name) WHERE condition; STRAIGHT_JOIN
强制按书写顺序连接JOIN表,固定连接顺序
索引分类 # 按数据结构分类索引 # B+tree索引 Hash索引 Full-text索引 按物理存储分类索引 # 聚簇索引（主键索引） 二级索引（辅助索引） 按字段特性分类索引 # 主键索引 唯一索引 普通索引 前缀索引 按字段个数分类索引 # 单列索引 联合索引 优化 # 覆盖索引 # 这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据
CREATE INDEX user_name_age ON user(name, age); SELECT name, age FROM user WHERE name = &amp;#39;Tom&amp;#39;; 索引下推 # 索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</description>
    </item>
    
    <item>
      <title>锁</title>
      <link>https://matteo-gz.github.io/coding/docs/mysql/lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matteo-gz.github.io/coding/docs/mysql/lock/</guid>
      <description>死锁 # 操作系统（四）—死锁
四个必要条件 # 互斥：在一个时间只能有一个进程使用资源。 请求和保持（持有并等待）：进程保持至少一个资源正在等待获取其他进程持有的额外资源。 不可抢占：一个资源只能在进程已经完成了它的任务之后，被自愿释放。 循环等待：存在n个进程，进行循环等待所占资源。 解决 # 死锁预防 死锁避免 死锁检测 死锁恢复 Mysql的锁
MySQL 有哪些锁？
根据锁粒度划分
全局锁 # Flush tables with read lock (FTWRL)
全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样
表级锁 # 表锁 # 表锁的语法
lock tables … read/write 表锁的例子
#表级别的共享锁，也就是读锁； lock tables t_student read; #表级别的独占锁，也就是写锁； lock tables t_stuent write; 主动释放
unlock tables 元数据锁 # meta data lock,MDL
MDL 锁是系统默认会加的
对一张表进行 CRUD 操作时，加的是 MDL 读锁； 对一张表做结构变更操作的时候，加的是 MDL 写锁； 例子: 给一个小表加个字段，导致整个库挂了
事务不提交，就会一直占着 MDL 锁,先暂停 DDL，或者 kill 掉这个长事务 针对热点表,在 alter table 语句里面设定等待时间,如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃 # NOWAIT: # 表示如果当前操作得不到表级别的元数据锁,会直接报错,不会等待锁释放。 # 通常情况下ALTER默认采用NOWAIT模式 ALTER TABLE tbl_name NOWAIT add column .</description>
    </item>
    
  </channel>
</rss>
